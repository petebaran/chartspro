<!DOCTYPE html>
<html>
<head>
  <style>
    * {
      box-sizing: border-box;
    }
    
    body {
      font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
      margin: 0;
      color: #1a1a1a;
      line-height: 1.4;
    }

    .container {
      max-width: 100%;
      background: rgb(226, 230, 232);
      border-radius: 0px;
      box-shadow: 0 2px 8px rgba(0,0,0,0.1);
      overflow: hidden;
    }

    .content {
      padding: 16px;
    }

    .section {
      margin-bottom: 16px;
      padding: 16px;
      background: #ffffff;
      border-radius: 6px;
    }

    .section-title {
      font-size: 14px;
      font-weight: 600;
      color: #4a5568;
      margin: 0 0
 12px 0;
      text-transform: none;
      letter-spacing: -0.1px;
    }

    #chart {
      height: 280px;
      margin-bottom: 20px; /* Increased margin */
      border-radius: 6px;
      overflow: hidden;
      border: 1px solid #e2e8f0;
      background: white;
      position: relative;
    }

    #chart canvas {
      width: 100%;
      height: 100%;
      cursor: crosshair;
    }

    .form-group {
      margin-bottom: 16px;
    }

    label {
      display: block;
      font-size: 12px;
      font-weight: 500;
      color: #4a5568;
      margin-bottom: 4px;
    }

    select, input, button {
      width: 100%;
      padding: 8px 12px;
      border: 1px solid #e2e8f0;
      border-radius: 4px;
      font-size: 13px;
      transition: all 0.2s ease;
    }

    select:focus, input:focus {
      outline: none;
      border-color: #000000;
      box-shadow: 0 0 0 3px rgba(0, 0, 0, 0.1);
    }

    .timeframes {
      display: grid;
      grid-template-columns: repeat(auto-fit, minmax(45px, 1fr));
      gap: 8px; /* Increased gap */
      margin-bottom: 20px; /* Increased margin */
    }

    .timeframes button {
      padding: 8px 6px;
      font-size: 11px;
      font-weight: 500;
      background: white;
      border: 1px solid #e2e8f0;
      color: #4a5568;
      cursor: pointer;
      transition: all 0.2s ease;
    }

    .timeframes button:hover {
      background: #f7fafc;
      border-color: #cbd5e0;
    }

    .timeframes button.active {
      background: #000000;
      color: white;
      border-color: #000000;
      box-shadow: 0 1px 3px rgba(0, 0, 0, 0.3);
    }

    .checkbox-grid {
      display: grid;
      grid-template-columns: 1fr 1fr;
      gap: 8px;
      margin-bottom: 16px;
    }

    .checkbox-item {
      display: flex;
      align-items: center;
      padding: 8px;
      background: white;
      border: 1px solid #e2e8f0;
      border-radius: 4px;
      cursor: pointer;
      transition: all 0.2s ease;
    }

    .checkbox-item:hover {
      background: #f7fafc;
    }

    .checkbox-item input[type="checkbox"] {
      margin: 0 8px 0 0;
      width: auto;
    }

    .checkbox-item label {
      margin: 0;
      font-size: 12px;
      cursor: pointer;
    }

    .size-inputs {
      display: grid;
      grid-template-columns: 1fr 1fr;
      gap: 16px; /* Increased gap */
      margin-bottom: 16px;
    }

    .color-inputs {
      display: grid;
      grid-template-columns: 1fr 1fr;
      gap: 16px; /* Increased gap */
      margin-bottom: 16px;
    }

    .color-input-group {
      display: flex;
      align-items: center;
      gap: 8px;
    }

    .color-input-group input[type="color"] {
      width: 40px;
      height: 32px;
      padding: 0;
      border: none;
      border-radius: 4px;
      cursor: pointer;
    }

    .color-input-group label {
      margin: 0;
      font-size: 12px;
      flex: 1;
    }

    .generate-btn {
      background: #000000;
      color: white;
      border: none;
      padding: 14px 20px; /* Bigger button */
      font-size: 14px;
      font-weight: 600;
      cursor: pointer;
      transition: all 0.2s ease;
      text-transform: none;
      letter-spacing: 0.5px;
      border-radius: 6px;
    }

    .generate-btn:hover {
      transform: translateY(-1px);
      box-shadow: 0 4px 12px rgba(0, 0, 0, 0.3);
      background: #333333;
    }

    .generate-btn:active {
      transform: translateY(0);
    }

    .search-box {
      position: relative;
      margin-bottom: 8px;
    }

    .search-box input {
      padding-left: 32px;
    }

    .search-icon {
      position: absolute;
      left: 10px;
      top: 50%;
      transform: translateY(-50%);
      color: #a0aec0;
      font-size: 14px;
    }

    .symbol-list {
      max-height: 200px;
      overflow-y: auto;
      border: 1px solid #e2e8f0;
      border-radius: 4px;
      background: white;
    }

    .symbol-option {
      padding: 8px 12px;
      cursor: pointer;
      border-bottom: 1px solid #f7fafc;
      font-size: 12px;
      transition: background-color 0.1s ease;
    }

    .symbol-option:hover {
      background: #f7fafc;
    }

    .symbol-option.selected {
      background: #000000;
      color: white;
    }

    .symbol-option:last-child {
      border-bottom: none;
    }

    .loading {
      text-align: center;
      padding: 20px;
      color: #718096;
      font-size: 13px;
    }

    .error {
      background: #fed7d7;
      color: #c53030;
      padding: 8px 12px;
      border-radius: 4px;
      font-size: 12px;
      margin-bottom: 16px;
    }

    .custom-range-section {
      background: #fff8dc;
    }

    /* Toggle Switch Styles */
    .toggle-switch {
      display: flex;
      align-items: center;
      gap: 12px;
      margin-bottom: 16px;
    }

    .toggle-switch label {
      margin: 0;
      font-size: 13px;
      font-weight: 500;
      color: #4a5568;
      cursor: pointer;
      transition: color 0.2s ease;
    }

    .toggle-switch label.active {
      color: #1a1a1a;
      font-weight: 600;
    }

    .toggle-container {
      position: relative;
      width: 52px;
      height: 28px;
      background: #e2e8f0;
      border-radius: 14px;
      cursor: pointer;
      transition: background-color 0.3s ease;
    }

    .toggle-slider {
      position: absolute;
      top: 2px;
      left: 2px;
      width: 24px;
      height: 24px;
      background: white;
      border-radius: 50%;
      transition: transform 0.3s ease;
      box-shadow: 0 2px 4px rgba(0, 0, 0, 0.2);
    }

    .toggle-container.active {
      background: #000000;
    }

    .toggle-container.active .toggle-slider {
      transform: translateX(24px);
    }
  </style>
</head>
<body>
  <div class="container">
    <div class="content">
      <div class="section">
        <h3 class="section-title">Chart Type</h3>
        <div class="toggle-switch">
          <label id="candlestickLabel" class="active">Candlestick</label>
          <div class="toggle-container" id="chartTypeToggle">
            <div class="toggle-slider"></div>
          </div>
          <label id="lineLabel">Line</label>
        </div>
      </div>

      <div class="section">
        <h3 class="section-title">Preview</h3>
        <div id="chart"></div>
        <div class="timeframes">
          <button data-days="1">1D</button>
          <button data-days="5">5D</button>
          <button data-days="30">1M</button>
          <button data-days="90">3M</button>
          <button data-days="180">6M</button>
          <button data-days="ytd">YTD</button>
          <button data-days="365">1Y</button>
          <button data-days="1825">5Y</button>
          <button data-days="max">All</button>
        </div>
      </div>

      <div class="section">
        <h3 class="section-title">Data Selection</h3>

        <div class="form-group">
          <label for="interval">Interval:</label>
          <select id="interval">
            <option value="MINUTE">1 minute</option>
            <option value="MINUTE_5">5 minutes</option>
            <option value="MINUTE_15">15 minutes</option>
            <option value="MINUTE_30">30 minutes</option>
            <option value="HOUR">1 hour</option>
            <option value="HOUR_4">4 hours</option>
            <option value="DAY">1 day</option>
            <option value="WEEK">1 week</option>
          </select>
        </div>

        <div class="form-group">
          <label for="category">Category:</label>
          <select id="category">
            <option value="stocks">US Stocks</option>
            <option value="crypto">Cryptocurrency</option>
            <option value="forex">Foreign Exchange</option>
            <option value="indices">World Indices</option>
            <option value="commodities">Commodities</option>
            <option value="etfs">ETFs</option>
          </select>
        </div>

        <div class="form-group">
          <label>Search Instrument:</label>
          <div class="search-box">
            <span class="search-icon">üîç</span>
            <input type="text" id="symbolSearch" placeholder="Search stocks, crypto, commodities...">
          </div>
          <div class="symbol-list" id="symbolList"></div>
        </div>
      </div>

      <div class="section custom-range-section">
        <h3 class="section-title">Custom Date Range</h3>
        <div class="form-group">
          <div class="checkbox-item">
            <input type="checkbox" id="useCustomRange">
            <label for="useCustomRange">Enable Custom Date Range</label>
          </div>
        </div>

        <div id="dateRangeInputs" style="display: none;">
          <div class="size-inputs">
            <div class="form-group">
              <label for="startDate">Start Date:</label>
              <input type="date" id="startDate">
            </div>
            <div class="form-group">
              <label for="endDate">End Date:</label>
              <input type="date" id="endDate">
            </div>
          </div>
          <button id="applyDateRange" class="generate-btn" style="font-size: 12px; padding: 8px 12px; margin-top: 8px;">Apply Date Range</button>
        </div>
      </div>

      <div class="section">
        <h3 class="section-title">Chart Appearance</h3>
        <div class="checkbox-grid">
          <div class="checkbox-item">
            <input type="checkbox" id="showPriceGrid" checked>
            <label for="showPriceGrid">Price Grid</label>
          </div>
          <div class="checkbox-item">
            <input type="checkbox" id="showDateGrid" checked>
            <label for="showDateGrid">Date Grid</label>
          </div>
          <div class="checkbox-item">
            <input type="checkbox" id="showVolume">
            <label for="showVolume">Volume Bars</label>
          </div>
          <div class="checkbox-item">
            <input type="checkbox" id="transparentBackground">
            <label for="transparentBackground">Transparent BG</label>
          </div>
        </div>

        <div class="color-inputs">
          <div class="color-input-group">
            <input type="color" id="bullColor" value="#00b386">
            <label for="bullColor">Bull Color</label>
          </div>
          <div class="color-input-group">
            <input type="color" id="bearColor" value="#ff4d4d">
            <label for="bearColor">Bear Color</label>
          </div>
        </div>

        <div class="form-group">
          <label for="strokeWeight">Stroke Weight (px):</label>
          <input type="number" id="strokeWeight" value="1" min="0.5" max="5" step="0.5">
        </div>
      </div>

      <div class="section">
        <h3 class="section-title">Chart Size</h3>
        <div class="size-inputs">
          <div class="form-group">
            <label for="chartWidth">Width (px):</label>
            <input type="number" id="chartWidth" value="600" min="300" max="2000" step="50">
          </div>
          <div class="form-group">
            <label for="chartHeight">Height (px):</label>
            <input type="number" id="chartHeight" value="400" min="300" max="1200" step="50">
          </div>
        </div>
      </div>

      <button id="generate" class="generate-btn">Generate Vector Chart</button>
    </div>
  </div>

  <script>
    // Comprehensive instrument database - Capital.com EPICs
    const instruments = {
      stocks: [
        { symbol: "AAPL", label: "Apple Inc. (AAPL)" },
        { symbol: "MSFT", label: "Microsoft Corporation (MSFT)" },
        { symbol: "GOOGL", label: "Alphabet Inc. (GOOGL)" },
        { symbol: "AMZN", label: "Amazon.com Inc. (AMZN)" },
        { symbol: "NVDA", label: "NVIDIA Corporation (NVDA)" },
        { symbol: "META", label: "Meta Platforms Inc. (META)" },
        { symbol: "TSLA", label: "Tesla Inc. (TSLA)" },
        { symbol: "BRKB", label: "Berkshire Hathaway Inc. Class B (BRKB)" },
        { symbol: "LLY", label: "Eli Lilly and Company (LLY)" },
        { symbol: "AVGO", label: "Broadcom Inc. (AVGO)" },
        { symbol: "JPM", label: "JPMorgan Chase & Co. (JPM)" },
        { symbol: "V", label: "Visa Inc. (V)" },
        { symbol: "UNH", label: "UnitedHealth Group Incorporated (UNH)" },
        { symbol: "XOM", label: "Exxon Mobil Corporation (XOM)" },
        { symbol: "JNJ", label: "Johnson & Johnson (JNJ)" },
        { symbol: "WMT", label: "Walmart Inc. (WMT)" },
        { symbol: "PG", label: "Procter & Gamble Company (PG)" },
        { symbol: "MA", label: "Mastercard Incorporated (MA)" },
        { symbol: "COST", label: "Costco Wholesale Corporation (COST)" },
        { symbol: "HD", label: "Home Depot Inc. (HD)" },
        { symbol: "BAC", label: "Bank of America Corp. (BAC)" },
        { symbol: "KO", label: "Coca-Cola Company (KO)" },
        { symbol: "PEP", label: "PepsiCo Inc. (PEP)" },
        { symbol: "MRK", label: "Merck & Co. Inc. (MRK)" },
        { symbol: "ORCL", label: "Oracle Corporation (ORCL)" },
        { symbol: "TSM", label: "Taiwan Semiconductor Manufacturing (TSM)" },
        { symbol: "ABBV", label: "AbbVie Inc. (ABBV)" },
        { symbol: "NVO", label: "Novo Nordisk A/S (NVO)" },
        { symbol: "ASML", label: "ASML Holding NV (ASML)" },
        { symbol: "MCD", label: "McDonald's Corporation (MCD)" },
        { symbol: "CRM", label: "Salesforce Inc. (CRM)" },
        { symbol: "ACN", label: "Accenture plc (ACN)" },
        { symbol: "DHR", label: "Danaher Corporation (DHR)" },
        { symbol: "NKE", label: "NIKE Inc. (NKE)" },
        { symbol: "AMD", label: "Advanced Micro Devices (AMD)" },
        { symbol: "PFE", label: "Pfizer Inc. (PFE)" },
        { symbol: "TMO", label: "Thermo Fisher Scientific Inc. (TMO)" },
        { symbol: "DIS", label: "Walt Disney Company (DIS)" },
        { symbol: "IBM", label: "International Business Machines (IBM)" },
        { symbol: "TXN", label: "Texas Instruments Incorporated (TXN)" },
        { symbol: "UPS", label: "United Parcel Service Inc. (UPS)" },
        { symbol: "QCOM", label: "QUALCOMM Inc. (QCOM)" },
        { symbol: "BABA", label: "Alibaba Group - China (BABA)" },
        { symbol: "NIO", label: "NIO Inc. - China (NIO)" },
        { symbol: "UBER", label: "Uber Technologies (UBER)" },
        { symbol: "PYPL", label: "PayPal Holdings Inc. (PYPL)" },
        { symbol: "ADBE", label: "Adobe Inc. (ADBE)" },
        { symbol: "CSCO", label: "Cisco Systems Inc. (CSCO)" },
        { symbol: "NFLX", label: "Netflix Inc. (NFLX)" },
        { symbol: "INTC", label: "Intel Corporation (INTC)" },
        { symbol: "PLTR", label: "Palantir Technologies Inc. (PLTR)" }
      ].sort((a, b) => a.label.localeCompare(b.label)),
      
      crypto: [
        { symbol: "BTCUSD", label: "Bitcoin (BTC)" },
        { symbol: "ETHUSD", label: "Ethereum (ETH)" },
        { symbol: "USDTUSD", label: "Tether (USDT)" },
        { symbol: "BNBUSD", label: "BNB (BNB)" },
        { symbol: "XRPUSD", label: "Ripple (XRP)" },
        { symbol: "ADAUSD", label: "Cardano (ADA)" },
        { symbol: "SOLUSD", label: "Solana (SOL)" },
        { symbol: "DOGEUSD", label: "Dogecoin (DOGE)" },
        { symbol: "TRXUSD", label: "TRON (TRX)" },
        { symbol: "MATICUSD", label: "Polygon (MATIC)" },
        { symbol: "DOTUSD", label: "Polkadot (DOT)" },
        { symbol: "LTCUSD", label: "Litecoin (LTC)" },
        { symbol: "BCHUSD", label: "Bitcoin Cash (BCH)" },
        { symbol: "LINKUSD", label: "Chainlink (LINK)" },
        { symbol: "XLMUSD", label: "Stellar Lumens (XLM)" },
        { symbol: "XMRUSD", label: "Monero (XMR)" },
        { symbol: "ATOMUSD", label: "Cosmos (ATOM)" },
        { symbol: "ETCUSD", label: "Ethereum Classic (ETC)" },
        { symbol: "AVAXUSD", label: "Avalanche (AVAX)" },
        { symbol: "ALGOUSD", label: "Algorand (ALGO)" },
        { symbol: "VETUSD", label: "VeChain (VET)" },
        { symbol: "UNIUSD", label: "Uniswap (UNI)" },
        { symbol: "APTUSD", label: "Aptos (APT)" },
        { symbol: "ARBUSD", label: "Arbitrum (ARB)" },
        { symbol: "NEARUSD", label: "NEAR Protocol (NEAR)" },
        { symbol: "ICPUSD", label: "Internet Computer (ICP)" },
        { symbol: "AAVEUSD", label: "Aave (AAVE)" },
        { symbol: "SUSHIUSD", label: "SushiSwap (SUSHI)" },
        { symbol: "GRTUSD", label: "The Graph (GRT)" },
        { symbol: "MANAUSD", label: "Decentraland (MANA)" },
        { symbol: "SANDUSD", label: "The Sandbox (SAND)" },
        { symbol: "AXSUSD", label: "Axie Infinity (AXS)" },
        { symbol: "XTZUSD", label: "Tezos (XTZ)" },
        { symbol: "EOSUSD", label: "EOS (EOS)" },
        { symbol: "THETAUSD", label: "Theta Network (THETA)" },
        { symbol: "FLOWUSD", label: "Flow (FLOW)" },
        { symbol: "HBARUSD", label: "Hedera (HBAR)" },
        { symbol: "FTMUSD", label: "Fantom (FTM)" },
        { symbol: "EGLDUSD", label: "MultiversX (EGLD)" },
        { symbol: "SNXUSD", label: "Synthetix (SNX)" },
        { symbol: "RUNEUSD", label: "THORChain (RUNE)" },
        { symbol: "KSMUSD", label: "Kusama (KSM)" },
        { symbol: "ZILUSD", label: "Zilliqa (ZIL)" },
        { symbol: "DASHUSD", label: "Dash (DASH)" },
        { symbol: "OMGUSD", label: "OMG Network (OMG)" },
        { symbol: "ZECUSD", label: "Zcash (ZEC)" },
        { symbol: "CHZUSD", label: "Chiliz (CHZ)" },
        { symbol: "ENJUSD", label: "Enjin Coin (ENJ)" },
        { symbol: "COMPUSD", label: "Compound (COMP)" },
        { symbol: "MKRUSD", label: "Maker (MKR)" }
      ].sort((a, b) => a.label.localeCompare(b.label)),
      
      etfs: [
        // SPDR ETFs
        { symbol: "SPY", label: "SPDR S&P 500 ETF Trust (SPY)" },
        { symbol: "XLF", label: "Financial Select Sector SPDR (XLF)" },
        { symbol: "XLK", label: "Technology Select Sector SPDR (XLK)" },
        { symbol: "XLE", label: "Energy Select Sector SPDR (XLE)" },
        { symbol: "XLV", label: "Health Care Select Sector SPDR (XLV)" },
        { symbol: "XLI", label: "Industrial Select Sector SPDR (XLI)" },
        { symbol: "XLY", label: "Consumer Discretionary Select Sector SPDR (XLY)" },
        { symbol: "XLP", label: "Consumer Staples Select Sector SPDR (XLP)" },
        { symbol: "XLB", label: "Materials Select Sector SPDR (XLB)" },
        { symbol: "XLU", label: "Utilities Select Sector SPDR (XLU)" },
        { symbol: "XLRE", label: "Real Estate Select Sector SPDR (XLRE)" },
        { symbol: "XLC", label: "Communication Services Select Sector SPDR (XLC)" },
        
        // Invesco ETFs
        { symbol: "QQQ", label: "Invesco QQQ Trust (QQQ)" },
        { symbol: "QYLD", label: "Global X NASDAQ 100 Covered Call ETF (QYLD)" },
        
        // iShares Core ETFs
        { symbol: "IVV", label: "iShares Core S&P 500 ETF (IVV)" },
        { symbol: "IWM", label: "iShares Russell 2000 ETF (IWM)" },
        { symbol: "IJH", label: "iShares Core S&P Mid-Cap ETF (IJH)" },
        { symbol: "IJR", label: "iShares Core S&P Small-Cap ETF (IJR)" },
        { symbol: "AGG", label: "iShares Core U.S. Aggregate Bond ETF (AGG)" },
        { symbol: "GOVT", label: "iShares U.S. Treasury Bond ETF (GOVT)" },
        { symbol: "IUSB", label: "iShares Core Total USD Bond Market ETF (IUSB)" },
        { symbol: "ISTB", label: "iShares Core 1-5 Year USD Bond ETF (ISTB)" },
        { symbol: "ILTB", label: "iShares Core 10+ Year USD Bond ETF (ILTB)" },
        { symbol: "MBB", label: "iShares MBS ETF (MBB)" },
        
        // iShares International ETFs
        { symbol: "EEM", label: "iShares MSCI Emerging Markets ETF (EEM)" },
        { symbol: "IEMG", label: "iShares Core MSCI Emerging Markets ETF (IEMG)" },
        { symbol: "EFA", label: "iShares MSCI EAFE ETF (EFA)" },
        { symbol: "IXUS", label: "iShares Core MSCI Total International Stock ETF (IXUS)" },
        { symbol: "EWJ", label: "iShares MSCI Japan ETF (EWJ)" },
        { symbol: "EWU", label: "iShares MSCI United Kingdom ETF (EWU)" },
        { symbol: "EWC", label: "iShares MSCI Canada ETF (EWC)" },
        { symbol: "EWG", label: "iShares MSCI Germany ETF (EWG)" },
        { symbol: "EWQ", label: "iShares MSCI France ETF (EWQ)" },
        { symbol: "EWA", label: "iShares MSCI Australia ETF (EWA)" },
        { symbol: "EWW", label: "iShares MSCI Mexico ETF (EWW)" },
        { symbol: "IEUR", label: "iShares Core MSCI Europe ETF (IEUR)" },
        { symbol: "IPAC", label: "iShares Core MSCI Pacific ETF (IPAC)" },
        { symbol: "AIA", label: "iShares Asia 50 ETF (AIA)" },
        { symbol: "IGRO", label: "iShares International Dividend Growth ETF (IGRO)" },
        
        // iShares Sector ETFs
        { symbol: "IYT", label: "iShares U.S. Transportation ETF (IYT)" },
        { symbol: "ITA", label: "iShares U.S. Aerospace & Defense ETF (ITA)" },
        { symbol: "IBB", label: "iShares Biotechnology ETF (IBB)" },
        { symbol: "IYE", label: "iShares U.S. Energy ETF (IYE)" },
        { symbol: "IYF", label: "iShares U.S. Financial Services ETF (IYF)" },
        { symbol: "IYW", label: "iShares U.S. Technology ETF (IYW)" },
        { symbol: "IYZ", label: "iShares U.S. Telecommunications ETF (IYZ)" },
        { symbol: "IYC", label: "iShares U.S. Consumer Discretionary ETF (IYC)" },
        { symbol: "IYH", label: "iShares U.S. Healthcare ETF (IYH)" },
        { symbol: "IYM", label: "iShares U.S. Basic Materials ETF (IYM)" },
        { symbol: "IYR", label: "iShares U.S. Real Estate ETF (IYR)" },
        { symbol: "IDU", label: "iShares U.S. Utilities ETF (IDU)" },
        
        // VanEck ETFs
        { symbol: "SMH", label: "VanEck Semiconductor ETF (SMH)" },
        { symbol: "GDX", label: "VanEck Gold Miners ETF (GDX)" },
        { symbol: "GDXJ", label: "VanEck Junior Gold Miners ETF (GDXJ)" },
        { symbol: "OIH", label: "VanEck Oil Services ETF (OIH)" },
        { symbol: "PPH", label: "VanEck Pharmaceutical ETF (PPH)" },
        { symbol: "NLR", label: "VanEck Uranium and Nuclear ETF (NLR)" },
        { symbol: "BBH", label: "VanEck Biotech ETF (BBH)" },
        { symbol: "HODL", label: "VanEck Bitcoin ETF (HODL)" },
        { symbol: "MOTI", label: "VanEck Morningstar International Moat ETF (MOTI)" },
        { symbol: "CLOI", label: "VanEck CLO ETF (CLOI)" },
        { symbol: "GPZ", label: "VanEck Alternative Asset Manager ETF (GPZ)" },
        { symbol: "REMX", label: "VanEck Rare Earth/Strategic Metals ETF (REMX)" },
        { symbol: "MOO", label: "VanEck Agribusiness ETF (MOO)" },
        { symbol: "RTH", label: "VanEck Retail ETF (RTH)" },
        { symbol: "PEK", label: "VanEck China A-Share ETF (PEK)" },
        { symbol: "RSX", label: "VanEck Russia ETF (RSX)" },
        { symbol: "ARKK", label: "ARK Innovation ETF (ARKK)" },
        { symbol: "ARKQ", label: "ARK Autonomous Technology & Robotics ETF (ARKQ)" },
        { symbol: "ARKG", label: "ARK Genomic Revolution ETF (ARKG)" },
        { symbol: "ARKF", label: "ARK Fintech Innovation ETF (ARKF)" },
        { symbol: "ARKW", label: "ARK Next Generation Internet ETF (ARKW)" },
        
        // Vanguard ETFs
        { symbol: "VTI", label: "Vanguard Total Stock Market ETF (VTI)" },
        { symbol: "VOO", label: "Vanguard S&P 500 ETF (VOO)" },
        { symbol: "VB", label: "Vanguard Small-Cap ETF (VB)" },
        { symbol: "VEA", label: "Vanguard FTSE Developed Markets ETF (VEA)" },
        { symbol: "VWO", label: "Vanguard FTSE Emerging Markets ETF (VWO)" },
        { symbol: "BND", label: "Vanguard Total Bond Market ETF (BND)" },
        { symbol: "VNQ", label: "Vanguard Real Estate ETF (VNQ)" },
        { symbol: "VGK", label: "Vanguard FTSE Europe ETF (VGK)" },
        { symbol: "VPL", label: "Vanguard FTSE Pacific ETF (VPL)" },
        { symbol: "VTEB", label: "Vanguard Tax-Exempt Bond ETF (VTEB)" },
        
        // Other Popular ETFs
        { symbol: "DIA", label: "SPDR Dow Jones Industrial Average ETF (DIA)" },
        { symbol: "TQQQ", label: "ProShares UltraPro QQQ (TQQQ)" },
        { symbol: "SQQQ", label: "ProShares UltraPro Short QQQ (SQQQ)" },
        { symbol: "UPRO", label: "ProShares UltraPro S&P500 (UPRO)" },
        { symbol: "SPXS", label: "Direxion Daily S&P 500 Bear 3X Shares (SPXS)" },
        { symbol: "JNK", label: "SPDR Bloomberg High Yield Bond ETF (JNK)" },
        { symbol: "HYG", label: "iShares iBoxx $ High Yield Corporate Bond ETF (HYG)" },
        { symbol: "GLD", label: "SPDR Gold Trust (GLD)" },
        { symbol: "SLV", label: "iShares Silver Trust (SLV)" },
        { symbol: "USO", label: "United States Oil Fund (USO)" },
        { symbol: "UNG", label: "United States Natural Gas Fund (UNG)" },
        { symbol: "SOXX", label: "iShares Semiconductor ETF (SOXX)" },
        { symbol: "FDN", label: "First Trust Dow Jones Internet Index Fund (FDN)" },
        { symbol: "XRT", label: "SPDR S&P Retail ETF (XRT)" },
        { symbol: "MJ", label: "ETFMG Alternative Harvest ETF (MJ)" }
      ].sort((a, b) => a.label.localeCompare(b.label)),
      
      commodities: [
        // Precious Metals (Verified from Capital.com API)
        { symbol: "GOLD", label: "Gold" },
        { symbol: "SILVER", label: "Silver" },
        { symbol: "PLATINUM", label: "Platinum" },
        { symbol: "PALLADIUM", label: "Palladium" },
        
        // Industrial Metals
        { symbol: "COPPER", label: "Copper" },
        { symbol: "ALUMINUM", label: "Aluminium Spot" },
        { symbol: "NICKEL", label: "Nickel" },
        { symbol: "LEAD", label: "Lead" },
        { symbol: "MZN3", label: "Zinc" },
        { symbol: "MCU3", label: "Copper UK" },
        
        // Energy
        { symbol: "OIL_CRUDE", label: "Crude Oil WTI" },
        { symbol: "OIL_BRENT", label: "Brent Oil" },
        { symbol: "NATURALGAS", label: "Natural Gas" },
        { symbol: "GASOLINE", label: "Gasoline" },
        { symbol: "HEATINGOIL", label: "Heating Oil" },
        
        // Agricultural Products
        { symbol: "CORN", label: "Corn" },
        { symbol: "WHEAT", label: "Wheat US" },
        { symbol: "SOYBEAN", label: "Soybean" },
        { symbol: "SOYBEANMEAL", label: "Soybean Meal" },
        { symbol: "SOYBEANOIL", label: "Soybean Oil" },
        { symbol: "OATS", label: "Oats" },
        { symbol: "RR", label: "Rough Rice" },
        
        // Soft Commodities
        { symbol: "COFFEEARABICA", label: "Coffee US" },
        { symbol: "LRC", label: "Coffee UK" },
        { symbol: "USCOCOA", label: "Cocoa US" },
        { symbol: "SB", label: "Sugar US" },
        { symbol: "UKSUGAR", label: "Sugar UK" },
        { symbol: "USCOTTON", label: "Cotton" },
        { symbol: "LUMBER", label: "Lumber" },
        
        // Livestock
        { symbol: "LEANHOGS", label: "Lean Hogs" }
      ].sort((a, b) => a.label.localeCompare(b.label)),
      
      indices: [
        // US Indices (Verified from Capital.com API)
        { symbol: "US500", label: "S&P 500" },
        { symbol: "US30", label: "Dow Jones 30 (Wall Street)" },
        { symbol: "US100", label: "NASDAQ 100 (Tech 100)" },
        { symbol: "RTY", label: "Russell 2000" },
        { symbol: "VIX", label: "VIX Volatility Index" },
        { symbol: "DXY", label: "US Dollar Index" },

        // European Indices (Verified from Capital.com API)
        { symbol: "UK100", label: "FTSE 100 UK" },
        { symbol: "DE40", label: "Germany 40 DAX" },
        { symbol: "FR40", label: "France 40 CAC" },
        { symbol: "IT40", label: "Italy 40 FTSE MIB" },
        { symbol: "SP35", label: "Spain 35 IBEX" },
        { symbol: "SW20", label: "Switzerland 20 SMI" },
        { symbol: "NL25", label: "Netherlands 25 AEX" },

        // Asia Pacific Indices (Verified from Capital.com API)
        { symbol: "CN50", label: "China A50" },
        { symbol: "SG25", label: "Singapore 25 Straits Times" }
      ].sort((a, b) => a.label.localeCompare(b.label)),
      
      forex: [
        // Major Currency Pairs (Verified from Capital.com API)
        { symbol: "EURUSD", label: "EUR/USD" },
        { symbol: "GBPUSD", label: "GBP/USD" },
        { symbol: "USDJPY", label: "USD/JPY" },
        { symbol: "USDCHF", label: "USD/CHF" },
        { symbol: "AUDUSD", label: "AUD/USD" },
        { symbol: "USDCAD", label: "USD/CAD" },
        { symbol: "NZDUSD", label: "NZD/USD" },
        
        // Cross Currency Pairs
        { symbol: "EURGBP", label: "EUR/GBP" },
        { symbol: "EURJPY", label: "EUR/JPY" },
        { symbol: "EURCHF", label: "EUR/CHF" },
        { symbol: "GBPJPY", label: "GBP/JPY" },
        { symbol: "GBPCHF", label: "GBP/CHF" },
        { symbol: "AUDCAD", label: "AUD/CAD" },
        { symbol: "AUDCHF", label: "AUD/CHF" },
        { symbol: "AUDJPY", label: "AUD/JPY" },
        { symbol: "CADJPY", label: "CAD/JPY" },
        { symbol: "CHFJPY", label: "CHF/JPY" },
        { symbol: "NZDJPY", label: "NZD/JPY" },
        { symbol: "NZDCHF", label: "NZD/CHF" },
        { symbol: "NZDCAD", label: "NZD/CAD" },
        
        // European Crosses
        { symbol: "EURHUF", label: "EUR/HUF" },
        { symbol: "EURPLN", label: "EUR/PLN" },
        { symbol: "EURSEK", label: "EUR/SEK" },
        { symbol: "EURNOK", label: "EUR/NOK" },
        { symbol: "EURNZD", label: "EUR/NZD" },
        { symbol: "EURTRY", label: "EUR/TRY" },
        { symbol: "EURZAR", label: "EUR/ZAR" },
        { symbol: "GBPHUF", label: "GBP/HUF" },
        { symbol: "GBPPLN", label: "GBP/PLN" },
        { symbol: "GBPSEK", label: "GBP/SEK" },
        { symbol: "GBPNOK", label: "GBP/NOK" },
        { symbol: "GBPNZD", label: "GBP/NZD" },
        
        // Asian & Emerging Markets
        { symbol: "USDHKD", label: "USD/HKD" },
        { symbol: "USDHUF", label: "USD/HUF" },
        { symbol: "USDPLN", label: "USD/PLN" },
        { symbol: "USDDKK", label: "USD/DKK" },
        { symbol: "AUDHKD", label: "AUD/HKD" },
        { symbol: "AUDSGD", label: "AUD/SGD" },
        { symbol: "CADHKD", label: "CAD/HKD" },
        { symbol: "CADSGD", label: "CAD/SGD" },
        { symbol: "CHFHKD", label: "CHF/HKD" },
        { symbol: "CHFSGD", label: "CHF/SGD" },
        { symbol: "EURHKD", label: "EUR/HKD" },
        { symbol: "EURSGD", label: "EUR/SGD" },
        { symbol: "GBPHKD", label: "GBP/HKD" },
        { symbol: "GBPSGD", label: "GBP/SGD" },
        { symbol: "NZDHKD", label: "NZD/HKD" },
        { symbol: "NZDSGD", label: "NZD/SGD" }
      ].sort((a, b) => a.label.localeCompare(b.label))
    };

    let currentSymbol = "AAPL";
    let filteredSymbols = [];
    let currentChartType = "candles";

    // Toggle switch functionality
    function updateChartType(type) {
      currentChartType = type;
      const toggle = document.getElementById('chartTypeToggle');
      const candlestickLabel = document.getElementById('candlestickLabel');
      const lineLabel = document.getElementById('lineLabel');

      if (type === 'line') {
        toggle.classList.add('active');
        candlestickLabel.classList.remove('active');
        lineLabel.classList.add('active');
      } else {
        toggle.classList.remove('active');
        candlestickLabel.classList.add('active');
        lineLabel.classList.remove('active');
      }

      // Re-render chart if data exists
      if (window.currentCanvasData) {
        if (type === 'line') {
          drawLineChart(window.currentCanvasData);
        } else {
          drawCandlestickChart(window.currentCanvasData);
        }
      }
    }

    function renderPreview(result) {
      const timestamps = result.timestamp;
      const ohlc = result.indicators.quote[0];

      // Filter data and prepare for custom drawing
      let filteredData = [];
      const interval = document.getElementById('interval').value;

      for (let i = 0; i < timestamps.length; i++) {
        const date = new Date(timestamps[i] * 1000);
        const dayOfWeek = date.getDay();

        // For daily+ intervals, skip weekends completely
        if (interval === 'DAY' || interval === 'WEEK') {
          if (dayOfWeek === 0 || dayOfWeek === 6) continue; // Skip weekends
        }

        if (ohlc.open[i] != null && ohlc.high[i] != null && ohlc.low[i] != null && ohlc.close[i] != null) {
          filteredData.push({
            date: date,
            open: ohlc.open[i],
            high: ohlc.high[i],
            low: ohlc.low[i],
            close: ohlc.close[i]
          });
        }
      }

      // Render based on chart type
      if (currentChartType === 'line') {
        drawLineChart(filteredData);
      } else {
        drawCandlestickChart(filteredData);
      }
    }

    function drawCandlestickChart(data) {
      const chartEl = document.getElementById("chart");
      chartEl.innerHTML = '<canvas id="candleCanvas"></canvas>';
      
      const canvas = document.getElementById('candleCanvas');
      const ctx = canvas.getContext('2d');
      
      // Set canvas size to match container
      const rect = chartEl.getBoundingClientRect();
      canvas.width = rect.width * window.devicePixelRatio;
      canvas.height = rect.height * window.devicePixelRatio;
      ctx.scale(window.devicePixelRatio, window.devicePixelRatio);
      
      const width = rect.width;
      const height = rect.height;
      
      if (data.length === 0) return;
      
      // Find price range
      let minPrice = Math.min(...data.map(d => d.low));
      let maxPrice = Math.max(...data.map(d => d.high));
      const priceRange = maxPrice - minPrice;
      minPrice -= priceRange * 0.1; // Add 10% padding
      maxPrice += priceRange * 0.1; // Add 10% padding
      const adjustedRange = maxPrice - minPrice;
      
      // Colors
      const bullColor = document.getElementById('bullColor').value;
      const bearColor = document.getElementById('bearColor').value;
      const gridColor = '#eef2f7'; // Lighter grid for a cleaner look
      const textColor = '#4a5568';
      
      // Get current timeframe to adjust labels
      const activeBtn = document.querySelector('.timeframes button.active');
      const days = activeBtn ? activeBtn.dataset.days : "30";

      // Clear canvas
      ctx.clearRect(0, 0, width, height);
      
      // STEP 1: First measure price text widths to determine layout
      ctx.fillStyle = textColor;
      ctx.font = '10px -apple-system, sans-serif';
      
      const numPriceLabels = 5;
      let maxPriceTextWidth = 0;
      
      // Measure all price texts to find the maximum width
      for (let i = 0; i <= numPriceLabels; i++) {
        const price = minPrice + (adjustedRange * (numPriceLabels - i) / numPriceLabels);
        
        // Format price with comma separators
        let formattedPrice;
        if (price >= 1) {
          formattedPrice = price.toFixed(2);
        } else if (price >= 0.01) {
          formattedPrice = price.toFixed(3);
        } else {
          formattedPrice = price.toFixed(6);
        }
        
        // Add comma separators
        const parts = formattedPrice.split('.');
        parts[0] = parts[0].replace(/\B(?=(\d{3})+(?!\d))/g, ',');
        const finalPrice = parts.join('.');
        
        const textWidth = ctx.measureText(finalPrice).width;
        maxPriceTextWidth = Math.max(maxPriceTextWidth, textWidth);
      }
      
      // STEP 2: Calculate layout based on measured text width
      const leftPadding = 16;
      const gapBetweenChartAndPrices = 24; // 10px gap between chart and price labels
      const rightPadding = maxPriceTextWidth + gapBetweenChartAndPrices + 8; // gap + margin
      const topPadding = 24;
      const bottomPadding = 30;
      
      const chartWidth = width - leftPadding - rightPadding;
      const chartHeight = height - topPadding - bottomPadding;
      const priceTextX = width - maxPriceTextWidth - 8; // Position text with 8px right margin
      
      // STEP 3: Draw grid lines if enabled
      if (document.getElementById('showPriceGrid').checked) {
        ctx.strokeStyle = gridColor;
        ctx.lineWidth = 1;
        ctx.setLineDash([2, 4]);
        for (let i = 0; i <= numPriceLabels; i++) {
          const y = topPadding + (chartHeight * i / numPriceLabels);
          ctx.beginPath();
          ctx.moveTo(leftPadding, y);
          ctx.lineTo(leftPadding + chartWidth, y);
          ctx.stroke();
        }
        ctx.setLineDash([]);
      }
      
      if (document.getElementById('showDateGrid').checked) {
        ctx.strokeStyle = gridColor;
        ctx.lineWidth = 1;
        ctx.setLineDash([2, 4]);
        const dateStep = Math.max(1, Math.floor(data.length / 5));
        for (let i = dateStep; i < data.length - 1; i += dateStep) {
          const x = leftPadding + (i / Math.max(1, data.length - 1)) * chartWidth;
          ctx.beginPath();
          ctx.moveTo(x, topPadding);
          ctx.lineTo(x, height - bottomPadding);
          ctx.stroke();
        }
        ctx.setLineDash([]);
      }
      
      // STEP 4: Draw price labels using the calculated position
      ctx.fillStyle = textColor;
      ctx.font = '10px -apple-system, sans-serif';
      ctx.textAlign = 'left';
      
      for (let i = 0; i <= numPriceLabels; i++) {
        const price = minPrice + (adjustedRange * (numPriceLabels - i) / numPriceLabels);
        const y = topPadding + (chartHeight * i / numPriceLabels);
        
        // Format price with comma separators
        let formattedPrice;
        if (price >= 1) {
          formattedPrice = price.toFixed(2);
        } else if (price >= 0.01) {
          formattedPrice = price.toFixed(3);
        } else {
          formattedPrice = price.toFixed(6);
        }
        
        // Add comma separators
        const parts = formattedPrice.split('.');
        parts[0] = parts[0].replace(/\B(?=(\d{3})+(?!\d))/g, ',');
        const finalPrice = parts.join('.');
        
        ctx.fillText(finalPrice, priceTextX, y + 3);
      }
      
      // STEP 5: Draw date/time labels based on timeframe
      ctx.textAlign = 'center';
      let dateIndices;
      if (days === '1') {
        dateIndices = [0, Math.floor((data.length - 1) / 3), Math.floor((data.length - 1) * 2 / 3), data.length - 1];
      } else {
        dateIndices = [0, Math.floor(data.length / 2), data.length - 1];
      }

      dateIndices.forEach((i, index) => {
        if (data[i]) {
          let x = leftPadding + (i / Math.max(1, data.length - 1)) * chartWidth;
          // Add padding for first and last labels
          if(index === 0) {
              x += 8;
          } else if(index === dateIndices.length - 1) {
              x -= gapBetweenChartAndPrices; // Move last date left by gap amount
          }

          let dateStr;
          if (days === '1') {
            dateStr = data[i].date.toLocaleTimeString('pl-PL', { 
              hour: '2-digit', 
              minute: '2-digit' 
            });
          } else {
            dateStr = data[i].date.toLocaleDateString('en-US', { 
              month: 'short', 
              day: 'numeric' 
            });
          }
          ctx.fillText(dateStr, x, height - bottomPadding + 15);
        }
      });
      
      // STEP 6: Draw candlesticks in the calculated chart area
      const candleWidth = Math.max(2, Math.min(10, chartWidth / data.length * 0.7));
      
      data.forEach((candle, i) => {
        const x = leftPadding + (i / Math.max(1, data.length - 1)) * chartWidth;
        const yHigh = topPadding + ((maxPrice - candle.high) / adjustedRange) * chartHeight;
        const yLow = topPadding + ((maxPrice - candle.low) / adjustedRange) * chartHeight;
        const yOpen = topPadding + ((maxPrice - candle.open) / adjustedRange) * chartHeight;
        const yClose = topPadding + ((maxPrice - candle.close) / adjustedRange) * chartHeight;
        
        const isBullish = candle.close >= candle.open;
        const color = isBullish ? bullColor : bearColor;
        
        ctx.strokeStyle = color;
        ctx.fillStyle = color;
        ctx.lineWidth = 1;
        
        // Draw wick
        ctx.beginPath();
        ctx.moveTo(x, yHigh);
        ctx.lineTo(x, yLow);
        ctx.stroke();
        
        // Draw body
        const bodyTop = Math.min(yOpen, yClose);
        const bodyHeight = Math.max(1, Math.abs(yClose - yOpen));
        ctx.fillRect(x - candleWidth/2, bodyTop, candleWidth, bodyHeight);
      });
      
      // Store data for color updates
      window.currentCanvasData = data;
    }

    function drawLineChart(data) {
      const chartEl = document.getElementById("chart");
      chartEl.innerHTML = '<canvas id="lineCanvas"></canvas>';

      const canvas = document.getElementById('lineCanvas');
      const ctx = canvas.getContext('2d');

      // Set canvas size to match container
      const rect = chartEl.getBoundingClientRect();
      canvas.width = rect.width * window.devicePixelRatio;
      canvas.height = rect.height * window.devicePixelRatio;
      ctx.scale(window.devicePixelRatio, window.devicePixelRatio);

      const width = rect.width;
      const height = rect.height;

      if (data.length === 0) return;

      // Find price range
      let minPrice = Math.min(...data.map(d => d.close));
      let maxPrice = Math.max(...data.map(d => d.close));
      const priceRange = maxPrice - minPrice;
      minPrice -= priceRange * 0.1; // Add 10% padding
      maxPrice += priceRange * 0.1; // Add 10% padding
      const adjustedRange = maxPrice - minPrice;

      // Colors
      const lineColor = data[data.length - 1].close >= data[0].open ?
        document.getElementById('bullColor').value :
        document.getElementById('bearColor').value;
      const gridColor = '#eef2f7';
      const textColor = '#4a5568';

      // Get current timeframe to adjust labels
      const activeBtn = document.querySelector('.timeframes button.active');
      const days = activeBtn ? activeBtn.dataset.days : "30";

      // Clear canvas
      ctx.clearRect(0, 0, width, height);

      // Layout
      ctx.fillStyle = textColor;
      ctx.font = '10px -apple-system, sans-serif';

      const numPriceLabels = 5;
      let maxPriceTextWidth = 0;

      // Measure all price texts to find the maximum width
      for (let i = 0; i <= numPriceLabels; i++) {
        const price = minPrice + (adjustedRange * (numPriceLabels - i) / numPriceLabels);
        let formattedPrice;
        if (price >= 1) {
          formattedPrice = price.toFixed(2);
        } else if (price >= 0.01) {
          formattedPrice = price.toFixed(3);
        } else {
          formattedPrice = price.toFixed(6);
        }
        const parts = formattedPrice.split('.');
        parts[0] = parts[0].replace(/\B(?=(\d{3})+(?!\d))/g, ',');
        const finalPrice = parts.join('.');
        const textWidth = ctx.measureText(finalPrice).width;
        maxPriceTextWidth = Math.max(maxPriceTextWidth, textWidth);
      }

      // Calculate layout
      const leftPadding = 16;
      const gapBetweenChartAndPrices = 24;
      const rightPadding = maxPriceTextWidth + gapBetweenChartAndPrices + 8;
      const topPadding = 24;
      const bottomPadding = 30;

      const chartWidth = width - leftPadding - rightPadding;
      const chartHeight = height - topPadding - bottomPadding;
      const priceTextX = width - maxPriceTextWidth - 8;

      // Draw grid lines if enabled
      if (document.getElementById('showPriceGrid').checked) {
        ctx.strokeStyle = gridColor;
        ctx.lineWidth = 1;
        ctx.setLineDash([2, 4]);
        for (let i = 0; i <= numPriceLabels; i++) {
          const y = topPadding + (chartHeight * i / numPriceLabels);
          ctx.beginPath();
          ctx.moveTo(leftPadding, y);
          ctx.lineTo(leftPadding + chartWidth, y);
          ctx.stroke();
        }
        ctx.setLineDash([]);
      }

      if (document.getElementById('showDateGrid').checked) {
        ctx.strokeStyle = gridColor;
        ctx.lineWidth = 1;
        ctx.setLineDash([2, 4]);
        const dateStep = Math.max(1, Math.floor(data.length / 5));
        for (let i = dateStep; i < data.length - 1; i += dateStep) {
          const x = leftPadding + (i / Math.max(1, data.length - 1)) * chartWidth;
          ctx.beginPath();
          ctx.moveTo(x, topPadding);
          ctx.lineTo(x, height - bottomPadding);
          ctx.stroke();
        }
        ctx.setLineDash([]);
      }

      // Draw price labels
      ctx.fillStyle = textColor;
      ctx.font = '10px -apple-system, sans-serif';
      ctx.textAlign = 'left';

      for (let i = 0; i <= numPriceLabels; i++) {
        const price = minPrice + (adjustedRange * (numPriceLabels - i) / numPriceLabels);
        const y = topPadding + (chartHeight * i / numPriceLabels);

        let formattedPrice;
        if (price >= 1) {
          formattedPrice = price.toFixed(2);
        } else if (price >= 0.01) {
          formattedPrice = price.toFixed(3);
        } else {
          formattedPrice = price.toFixed(6);
        }
        const parts = formattedPrice.split('.');
        parts[0] = parts[0].replace(/\B(?=(\d{3})+(?!\d))/g, ',');
        const finalPrice = parts.join('.');

        ctx.fillText(finalPrice, priceTextX, y + 3);
      }

      // Draw date labels
      ctx.textAlign = 'center';
      let dateIndices;
      if (days === '1') {
        dateIndices = [0, Math.floor((data.length - 1) / 3), Math.floor((data.length - 1) * 2 / 3), data.length - 1];
      } else {
        dateIndices = [0, Math.floor(data.length / 2), data.length - 1];
      }

      dateIndices.forEach((i, index) => {
        if (data[i]) {
          let x = leftPadding + (i / Math.max(1, data.length - 1)) * chartWidth;
          if (index === 0) {
            x += 8;
          } else if (index === dateIndices.length - 1) {
            x -= gapBetweenChartAndPrices;
          }

          let dateStr;
          if (days === '1') {
            dateStr = data[i].date.toLocaleTimeString('pl-PL', {
              hour: '2-digit',
              minute: '2-digit'
            });
          } else {
            dateStr = data[i].date.toLocaleDateString('en-US', {
              month: 'short',
              day: 'numeric'
            });
          }
          ctx.fillText(dateStr, x, height - bottomPadding + 15);
        }
      });

      // Draw line chart
      const strokeWeight = parseFloat(document.getElementById('strokeWeight').value) || 1;
      ctx.strokeStyle = lineColor;
      ctx.lineWidth = strokeWeight * 2; // Line charts look better with thicker lines
      ctx.lineJoin = 'round';
      ctx.lineCap = 'round';

      ctx.beginPath();
      data.forEach((point, i) => {
        const x = leftPadding + (i / Math.max(1, data.length - 1)) * chartWidth;
        const y = topPadding + ((maxPrice - point.close) / adjustedRange) * chartHeight;

        if (i === 0) {
          ctx.moveTo(x, y);
        } else {
          ctx.lineTo(x, y);
        }
      });
      ctx.stroke();

      // Optionally fill area under line with gradient
      if (document.getElementById('showVolume').checked) {
        const gradient = ctx.createLinearGradient(0, topPadding, 0, height - bottomPadding);
        const rgb = hexToRgb(lineColor);
        gradient.addColorStop(0, `rgba(${rgb.r * 255}, ${rgb.g * 255}, ${rgb.b * 255}, 0.3)`);
        gradient.addColorStop(1, `rgba(${rgb.r * 255}, ${rgb.g * 255}, ${rgb.b * 255}, 0.0)`);

        ctx.fillStyle = gradient;
        ctx.beginPath();
        data.forEach((point, i) => {
          const x = leftPadding + (i / Math.max(1, data.length - 1)) * chartWidth;
          const y = topPadding + ((maxPrice - point.close) / adjustedRange) * chartHeight;
          if (i === 0) {
            ctx.moveTo(x, y);
          } else {
            ctx.lineTo(x, y);
          }
        });
        ctx.lineTo(leftPadding + chartWidth, height - bottomPadding);
        ctx.lineTo(leftPadding, height - bottomPadding);
        ctx.closePath();
        ctx.fill();
      }

      // Store data for updates
      window.currentCanvasData = data;
      window.currentChartType = 'line';
    }

    function hexToRgb(hex) {
      const bigint = parseInt(hex.slice(1), 16);
      return {
        r: ((bigint >> 16) & 255) / 255,
        g: ((bigint >> 8) & 255) / 255,
        b: (bigint & 255) / 255
      };
    }

    function updateIntervalOptions(days) {
      const intervalSelect = document.getElementById('interval');
      const currentInterval = intervalSelect.value;

      // Capital.com API-validated interval mappings
      // Based on actual API data availability testing
      const validIntervals = {
        "1": [
          // 1 Day - API supports 5min+ for intraday
          { value: "MINUTE_5", label: "5 minutes", default: true },
          { value: "MINUTE_15", label: "15 minutes" },
          { value: "MINUTE_30", label: "30 minutes" }
        ],
        "5": [
          // 5 Days - API supports 15min+ reliably
          { value: "MINUTE_15", label: "15 minutes", default: true },
          { value: "MINUTE_30", label: "30 minutes" },
          { value: "HOUR", label: "1 hour" }
        ],
        "30": [
          // 1 Month - API supports hourly+
          { value: "HOUR", label: "1 hour" },
          { value: "HOUR_4", label: "4 hours", default: true },
          { value: "DAY", label: "1 day" }
        ],
        "90": [
          // 3 Months - Use 4h or daily
          { value: "HOUR_4", label: "4 hours" },
          { value: "DAY", label: "1 day", default: true }
        ],
        "180": [
          // 6 Months - Daily recommended
          { value: "HOUR_4", label: "4 hours" },
          { value: "DAY", label: "1 day", default: true },
          { value: "WEEK", label: "1 week" }
        ],
        "365": [
          // 1 Year - Daily or weekly
          { value: "DAY", label: "1 day", default: true },
          { value: "WEEK", label: "1 week" }
        ],
        "ytd": [
          // Year to Date
          { value: "DAY", label: "1 day", default: true },
          { value: "WEEK", label: "1 week" }
        ],
        "1825": [
          // 5 Years - Weekly recommended for performance
          { value: "DAY", label: "1 day" },
          { value: "WEEK", label: "1 week", default: true }
        ],
        "max": [
          // All time
          { value: "WEEK", label: "1 week", default: true }
        ],
        "custom": [
          // Custom range - offer all validated intervals
          { value: "MINUTE_5", label: "5 minutes" },
          { value: "MINUTE_15", label: "15 minutes" },
          { value: "MINUTE_30", label: "30 minutes" },
          { value: "HOUR", label: "1 hour" },
          { value: "HOUR_4", label: "4 hours" },
          { value: "DAY", label: "1 day", default: true },
          { value: "WEEK", label: "1 week" }
        ]
      };

      const intervals = validIntervals[days] || validIntervals["30"];
      intervalSelect.innerHTML = '';

      intervals.forEach(interval => {
        const option = document.createElement('option');
        option.value = interval.value;
        option.textContent = interval.label;
        intervalSelect.appendChild(option);
      });

      // Smart default selection
      if (intervals.some(i => i.value === currentInterval)) {
        // Keep current selection if valid
        intervalSelect.value = currentInterval;
      } else {
        // Use marked default or first option
        const defaultInterval = intervals.find(i => i.default) || intervals[0];
        intervalSelect.value = defaultInterval.value;
      }
    }

    function fetchChart(days, symbol) {
      const now = Math.floor(Date.now() / 1000);
      let start;

      updateIntervalOptions(days);
      const interval = document.getElementById('interval').value;
      const useCustomRange = document.getElementById('useCustomRange').checked;

      if (useCustomRange && days === 'custom') {
        const startDate = document.getElementById('startDate').value;
        const endDate = document.getElementById('endDate').value;
        
        if (startDate && endDate) {
          start = Math.floor(new Date(startDate).getTime() / 1000);
          const end = Math.floor(new Date(endDate).getTime() / 1000);
          
          const from = new Date(startDate).toISOString();
          const to = new Date(endDate).toISOString();
          const url = 'https://capitalcom-charts-proxy.petebaranescu.workers.dev/chart?epic=' + symbol + '&resolution=' + interval + '&from=' + from + '&to=' + to;
          
          document.getElementById('chart').innerHTML = '<div class="loading">Loading custom date range...</div>';
          
          fetch(url)
            .then(res => {
              console.log('Custom range response status:', res.status);
              if (!res.ok) {
                throw new Error('HTTP error! status: ' + res.status);
              }
              return res.json();
            })
            .then(json => {
              console.log('Custom range received data:', json);
              const result = json.chart.result[0];
              window.chartData = result;
              renderPreview(result);
            })
            .catch(error => {
              console.error('Error fetching data:', error);
              document.getElementById('chart').innerHTML = '<div class="error">Error loading chart data. Please try again.</div>';
            });
          return;
        } else {
          alert('Please select both start and end dates.');
          return;
        }
      }

      // Standard timeframe logic
      if (days === "ytd") {
        const jan1 = new Date(new Date().getFullYear(), 0, 1).getTime();
        start = Math.floor(jan1 / 1000);
      } else if (days !== "max") {
        start = now - days * 24 * 60 * 60;
      }

      // Convert timestamps to ISO date strings for Capital.com API
      const fromDate = start ? new Date(start * 1000).toISOString() : '';
      const toDate = new Date(now * 1000).toISOString();
      const url = 'https://capitalcom-charts-proxy.petebaranescu.workers.dev/chart?epic=' + symbol + '&resolution=' + interval + (fromDate ? '&from=' + fromDate + '&to=' + toDate : '');

      document.getElementById('chart').innerHTML = '<div class="loading">Loading chart data...</div>';

      console.log('Fetching URL:', url);
      fetch(url)
        .then(res => {
          console.log('Response status:', res.status);
          if (!res.ok) {
            return res.text().then(text => {
              console.error('Error response body:', text);
              throw new Error('HTTP error! status: ' + res.status + ' - ' + text.substring(0, 200));
            });
          }
          return res.json();
        })
        .then(json => {
          console.log('Received data:', json);
          if (!json.chart || !json.chart.result || !json.chart.result[0]) {
            throw new Error('Invalid data format received');
          }
          const result = json.chart.result[0];
          
          // Filter weekends for daily+ intervals
          if (interval === 'DAY' || interval === 'WEEK') {
            const filteredTimestamps = [];
            const filteredOpen = [];
            const filteredHigh = [];
            const filteredLow = [];
            const filteredClose = [];
            const filteredVolume = [];
            
            for (let i = 0; i < result.timestamp.length; i++) {
              const date = new Date(result.timestamp[i] * 1000);
              const dayOfWeek = date.getDay();
              
              // Keep weekdays (1-5), filter out weekends (0=Sunday, 6=Saturday)
              if (dayOfWeek >= 1 && dayOfWeek <= 5) {
                filteredTimestamps.push(result.timestamp[i]);
                filteredOpen.push(result.indicators.quote[0].open[i]);
                filteredHigh.push(result.indicators.quote[0].high[i]);
                filteredLow.push(result.indicators.quote[0].low[i]);
                filteredClose.push(result.indicators.quote[0].close[i]);
                if (result.indicators.quote[0].volume && result.indicators.quote[0].volume[i] != null) {
                  filteredVolume.push(result.indicators.quote[0].volume[i]);
                }
              }
            }
            
            // Update the result with filtered data
            result.timestamp = filteredTimestamps;
            result.indicators.quote[0].open = filteredOpen;
            result.indicators.quote[0].high = filteredHigh;
            result.indicators.quote[0].low = filteredLow;
            result.indicators.quote[0].close = filteredClose;
            if (result.indicators.quote[0].volume) {
              result.indicators.quote[0].volume = filteredVolume;
            }
          }
          
          window.chartData = result;
          renderPreview(result);
        })
        .catch(error => {
          console.error('Error fetching data:', error);
          document.getElementById('chart').innerHTML = '<div class="error">Error loading chart data. Please try again.</div>';
        });
    }

    function filterSymbols(searchTerm) {
      const categorySelect = document.getElementById('category');
      const selectedCategory = categorySelect.value;
      const symbols = instruments[selectedCategory] || [];
      
      if (!searchTerm) {
        filteredSymbols = symbols;
      } else {
        filteredSymbols = symbols.filter(symbol => 
          symbol.label.toLowerCase().includes(searchTerm.toLowerCase()) ||
          symbol.symbol.toLowerCase().includes(searchTerm.toLowerCase())
        );
      }
      
      renderSymbolList();
    }

    function renderSymbolList() {
      const symbolList = document.getElementById('symbolList');
      symbolList.innerHTML = '';
      
      // Show ALL filtered symbols
      filteredSymbols.forEach(symbol => {
        const div = document.createElement('div');
        div.className = 'symbol-option';
        if (symbol.symbol === currentSymbol) {
          div.classList.add('selected');
        }
        div.textContent = symbol.label;
        div.addEventListener('click', () => selectSymbol(symbol.symbol));
        symbolList.appendChild(div);
      });
    }

    function selectSymbol(symbol) {
      currentSymbol = symbol;
      const foundSymbol = filteredSymbols.find(s => s.symbol === symbol);
      document.getElementById('symbolSearch').value = foundSymbol ? foundSymbol.label : symbol;
      renderSymbolList();
      
      const activeBtn = document.querySelector('.timeframes button.active');
      const days = activeBtn ? activeBtn.dataset.days : "30";
      fetchChart(days, symbol);
    }

    // Event Listeners
    document.getElementById('generate').addEventListener('click', function() {
      if (window.chartData) {
        const width = parseInt(document.getElementById('chartWidth').value);
        const height = parseInt(document.getElementById('chartHeight').value);
        const bullColor = document.getElementById('bullColor').value;
        const bearColor = document.getElementById('bearColor').value;
        const interval = document.getElementById('interval').value;
        const useCustomRange = document.getElementById('useCustomRange').checked;
        const strokeWeight = parseFloat(document.getElementById('strokeWeight').value) || 1;
        const chartType = currentChartType;

        let timeframe;
        if (useCustomRange) {
          const startDate = document.getElementById('startDate').value;
          const endDate = document.getElementById('endDate').value;
          timeframe = 'Custom (' + startDate + ' to ' + endDate + ')';
        } else {
          const activeBtn = document.querySelector('.timeframes button.active');
          timeframe = activeBtn ? activeBtn.dataset.days : "30";
        }

        parent.postMessage({
          pluginMessage: {
            type: 'chart-data',
            data: window.chartData,
            interval: interval,
            timeframe: timeframe,
            chartType: chartType,
            config: {
              width: width,
              height: height,
              bullColor: bullColor,
              bearColor: bearColor,
              showPriceGrid: document.getElementById('showPriceGrid').checked,
              showDateGrid: document.getElementById('showDateGrid').checked,
              showVolume: document.getElementById('showVolume').checked,
              transparentBackground: document.getElementById('transparentBackground').checked,
              strokeWeight: strokeWeight,
              chartType: chartType
            }
          }
        }, '*');
      } else {
        alert('No chart data available. Please wait for data to load.');
      }
    });

    document.getElementById('category').addEventListener('change', function() {
      filterSymbols('');
      document.getElementById('symbolSearch').value = '';
      if (filteredSymbols.length > 0) {
        selectSymbol(filteredSymbols[0].symbol);
      }
    });

    document.getElementById('symbolSearch').addEventListener('input', function(e) {
      filterSymbols(e.target.value);
    });

    document.querySelectorAll('.timeframes button').forEach(btn => {
      btn.addEventListener('click', function() {
        document.querySelectorAll('.timeframes button').forEach(b => b.classList.remove('active'));
        btn.classList.add('active');
        document.getElementById('useCustomRange').checked = false;
        document.getElementById('dateRangeInputs').style.display = 'none';
        document.querySelector('.timeframes').style.opacity = '1';
        document.querySelector('.timeframes').style.pointerEvents = 'auto';
        fetchChart(btn.dataset.days, currentSymbol);
      });
    });

    // Add interval change listener
    document.getElementById('interval').addEventListener('change', function() {
      const useCustomRange = document.getElementById('useCustomRange').checked;
      if (useCustomRange) {
        fetchChart('custom', currentSymbol);
      } else {
        const activeBtn = document.querySelector('.timeframes button.active');
        const days = activeBtn ? activeBtn.dataset.days : "30";
        fetchChart(days, currentSymbol);
      }
    });

    // Custom date range toggle
    document.getElementById('useCustomRange').addEventListener('change', function(e) {
      const dateRangeInputs = document.getElementById('dateRangeInputs');
      
      if (e.target.checked) {
        dateRangeInputs.style.display = 'block';
        timeframes.style.opacity = '0.5';
        timeframes.style.pointerEvents = 'none';
        
        // Clear active timeframe buttons
        document.querySelectorAll('.timeframes button').forEach(b => b.classList.remove('active'));
        
        // Set default dates (last 3 months)
        const endDate = new Date();
        const startDate = new Date();
        startDate.setMonth(endDate.getMonth() - 3);
        
        document.getElementById('endDate').value = endDate.toISOString().split('T')[0];
        document.getElementById('startDate').value = startDate.toISOString().split('T')[0];
      } else {
        dateRangeInputs.style.display = 'none';
        timeframes.style.opacity = '1';
        timeframes.style.pointerEvents = 'auto';
        
        // Reactivate default timeframe
        const defaultButton = document.querySelector('[data-days="30"]');
        if (defaultButton) {
          defaultButton.classList.add('active');
          fetchChart("30", currentSymbol);
        }
      }
    });

    // Apply custom date range
    document.getElementById('applyDateRange').addEventListener('click', function() {
      fetchChart('custom', currentSymbol);
    });

    // Chart type toggle listeners
    document.getElementById('chartTypeToggle').addEventListener('click', function() {
      updateChartType(currentChartType === 'candles' ? 'line' : 'candles');
    });

    document.getElementById('candlestickLabel').addEventListener('click', function() {
      updateChartType('candles');
    });

    document.getElementById('lineLabel').addEventListener('click', function() {
      updateChartType('line');
    });

    // Color change listeners to update preview
    document.getElementById('bullColor').addEventListener('change', function() {
      if (window.currentCanvasData) {
        if (currentChartType === 'line') {
          drawLineChart(window.currentCanvasData);
        } else {
          drawCandlestickChart(window.currentCanvasData);
        }
      }
    });

    document.getElementById('bearColor').addEventListener('change', function() {
      if (window.currentCanvasData) {
        if (currentChartType === 'line') {
          drawLineChart(window.currentCanvasData);
        } else {
          drawCandlestickChart(window.currentCanvasData);
        }
      }
    });

    // Grid change listeners
    document.getElementById('showPriceGrid').addEventListener('change', function() {
      if (window.currentCanvasData) {
        if (currentChartType === 'line') {
          drawLineChart(window.currentCanvasData);
        } else {
          drawCandlestickChart(window.currentCanvasData);
        }
      }
    });

    document.getElementById('showDateGrid').addEventListener('change', function() {
      if (window.currentCanvasData) {
        if (currentChartType === 'line') {
          drawLineChart(window.currentCanvasData);
        } else {
          drawCandlestickChart(window.currentCanvasData);
        }
      }
    });

    // Initialize
    window.addEventListener('load', function() {
      console.log('Initializing CC Charts Pro...');
      const categorySelect = document.getElementById('category');
      
      // Clear and populate categories
      categorySelect.innerHTML = '';
      Object.keys(instruments).forEach(cat => {
        const opt = document.createElement('option');
        opt.value = cat;
        opt.textContent = cat.charAt(0).toUpperCase() + cat.slice(1);
        categorySelect.appendChild(opt);
      });
      
      // Set default to stocks and initialize
      categorySelect.value = 'stocks';
      filterSymbols('');
      
      if (filteredSymbols.length > 0) {
        selectSymbol(filteredSymbols[0].symbol);
      }
      
      const defaultButton = document.querySelector('[data-days="30"]');
      if (defaultButton) {
        defaultButton.classList.add('active');
        fetchChart("30", currentSymbol);
      }
    });
  </script>
</body>
</html>
